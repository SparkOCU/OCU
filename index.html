<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Fuel Control</title>
    <style>
        body {
            font-family: Arial;
            margin: 10px;
            background: #f0f0f0;
        }
        .header {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .logo {
            height: 30px;
            margin-right: 5px;
        }
        select, button {
            height: 30px;
            margin-right: 5px;
            font-size: 12px;
            padding: 2px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            transition: background 0.3s;
        }
        button:hover {
            background: #1976D2;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #connectBtn.connected {
            background: #4CAF50;
        }
        .parameter-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
            padding: 8px;
            background: white;
            border-radius: 4px;
        }
        label {
            width: 100px;
            font-size: 13px;
            color: #666;
        }
        input {
            width: 150px;
            height: 24px;
            padding: 2px 8px;
            font-size: 13px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        input:focus {
            outline: none;
            border-color: #2196F3;
        }
        input[readonly] {
            background: #f8f8f8;
            color: #666;
        }
        .current-value {
            margin-left: 10px;
            font-size: 13px;
            color: #2196F3;
            font-weight: bold;
            min-width: 200px;
        }
        .last-value {
            color: #666;
            font-weight: normal;
        }
        .calibration {
            margin-top: 20px;
            background: white;
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .calibration h3 {
            font-size: 14px;
            margin: 0 0 15px 0;
            color: #333;
        }
        #calibrationTable {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }
        #calibrationTable th,
        #calibrationTable td {
            padding: 8px;
            text-align: left;
            font-size: 13px;
            border-bottom: 1px solid #eee;
        }
        #calibrationTable th {
            background: #f5f5f5;
            font-weight: bold;
            color: #333;
        }
        #calibrationTable input {
            width: 100px;
        }
        #statusBar {
            margin-top: 15px;
            padding: 10px;
            text-align: center;
            border-radius: 4px;
            font-size: 13px;
            background: #f5f5f5;
            color: #666;
        }
        #statusBar.connected {
            background: #4CAF50;
            color: white;
        }
        #statusBar.error {
            background: #f44336;
            color: white;
        }
        .parameters {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .active-row {
            background-color: #e3f2fd;
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="abhivijay.png" alt="Logo" class="logo">
        <select id="portSelect">
            <option value="">Select Port</option>
        </select>
        <button id="saveBtn" disabled>Save</button>
        <button id="loadBtn" disabled>Load</button>
        <button id="connectBtn">Connect</button>
    </div>

    <div class="parameters">
        <div class="parameter-row">
            <label>Frequency (Hz):</label>
            <input type="number" id="frequency" readonly step="0.01" value="0">
        </div>
        <div class="parameter-row">
            <label>RPM:</label>
            <input type="number" id="rpm" step="100" min="0" max="10000" value="0">
            <span id="current-rpm" class="current-value"></span>
        </div>
        <div class="parameter-row">
            <label>Oil %:</label>
            <input type="number" id="oil" readonly step="0.1" value="0">
        </div>
        <div class="parameter-row">
            <label>PWM L (ms):</label>
            <input type="number" id="pwml" readonly step="0.01" value="900">
        </div>
    </div>

    <div class="calibration">
        <h3>RPM/Oil Percentage Calibration</h3>
        <table id="calibrationTable">
            <thead>
                <tr>
                    <th>Default RPM</th>
                    <th>Set RPM</th>
                    <th>Set Oil %</th>
                    <th>Existing Values</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    </div>

    <div id="statusBar">Not Connected</div>
    <script>
        // Constants
        const RPM_VALUES = [0, 1500, 2000, 2500, 3000, 3500, 4000, 4500, 5000];
        const DEFAULT_OIL_VALUES = [0, 10, 40, 90, 90, 90, 90, 90, 90];
        let currentRPMValues = [...RPM_VALUES];
        let lastValidData = {
            rpm: 0,
            oil: 0,
            freq: 0,
            pwml: 900
        };
        
        // Connection variables
        let port = null;
        let reader = null;
        let writer = null;
        let dataBuffer = '';
        let isConnected = false;
        let lastActiveRow = null;
        let tableData = [];

        // Initialize calibration table
        function initializeTable() {
            const tbody = document.querySelector('#calibrationTable tbody');
            tbody.innerHTML = '';
            
            for(let i = 0; i < RPM_VALUES.length; i++) {
                const tr = document.createElement('tr');
                tr.dataset.index = i;
                
                tr.innerHTML = `
                    <td>${i + 1}</td>  <!-- Changed from i to i+1 -->
                    <td>
                        <input type="number" class="rpm-input" placeholder="Enter RPM" 
                            min="0" max="10000" step="100">
                    </td>
                    <td>
                        <input type="number" class="oil-input" placeholder="Enter Oil %" 
                            min="0" max="100" step="0.1">
                    </td>
                    <td class="current-value">No value set</td>
                `;
                tbody.appendChild(tr);
            }
            addTableInputListeners();
        }

        // Fix addTableInputListeners function
        function addTableInputListeners() {
            document.querySelectorAll('.rpm-input').forEach((input, index) => {
                input.addEventListener('change', async function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 10000) {
                        await sendCommand(SET_RPM:${index},${value});
                        this.value = '';
                        this.placeholder = 'Value sent';
                        setTimeout(() => {
                            this.placeholder = 'Enter RPM';
                        }, 2000);
                    }
                });
            });

            document.querySelectorAll('.oil-input').forEach((input, index) => {
                input.addEventListener('change', async function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 100) {
                        await sendCommand(SET_OIL:${index},${value.toFixed(1)});
                        this.value = '';
                        this.placeholder = 'Value sent';
                        setTimeout(() => {
                            this.placeholder = 'Enter Oil %';
                        }, 2000);
                    }
                });
            });
        }

        // Add input event listeners to table
        function addTableInputListeners() {
            document.querySelectorAll('.rpm-input').forEach((input, index) => {
                input.addEventListener('change', async function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 10000) {
                        // Send index-1 to match Arduino's 0-based array
                        await sendCommand(SET_RPM:${index},${value});
                        this.value = '';
                        this.placeholder = 'Value sent';
                        setTimeout(() => {
                            this.placeholder = 'Enter RPM';
                        }, 2000);
                    }
                });
            });

            document.querySelectorAll('.oil-input').forEach((input, index) => {
                input.addEventListener('change', async function() {
                    const value = parseFloat(this.value);
                    if (!isNaN(value) && value >= 0 && value <= 100) {
                        // Send index-1 to match Arduino's 0-based array
                        await sendCommand(SET_OIL:${index},${value.toFixed(1)});
                        this.value = '';
                        this.placeholder = 'Value sent';
                        setTimeout(() => {
                            this.placeholder = 'Enter Oil %';
                        }, 2000);
                    }
                });
            });
        }

        // Update port selection handling
        async function updatePorts() {
            const ports = await navigator.serial.getPorts();
            const select = document.getElementById('portSelect');
            select.innerHTML = '<option value="">Select Port</option>';
            
            for (const port of ports) {
                const option = document.createElement('option');
                option.value = port.getInfo().usbVendorId;
                option.text = Port ${port.getInfo().usbVendorId};
                select.appendChild(option);
            }
        }

        // Add new timeout and retry variables
        let connectionTimeout = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        const RECONNECT_DELAY = 2000;
        
        // Improved connect function
        async function connect() {
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
            }
            
            if (port) {
                await disconnect();
                return;
            }
            
            try {
                reconnectAttempts = 0;
                port = await navigator.serial.requestPort();
                await connectPort();
            } catch (error) {
                console.error('Connection error:', error);
                await handleConnectionError(error);
            }
        }

        // New function to handle port connection
        async function connectPort() {
            try {
                await port.open({ 
                    baudRate: 115200,
                    dataBits: 8,
                    stopBits: 1,
                    parity: "none",
                    bufferSize: 4096,
                    flowControl: "none"
                });

                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                updateConnectionStatus(true);
                startReading();
                startKeepAlive();

                // Set connection timeout
                connectionTimeout = setTimeout(checkConnection, 5000);
            } catch (error) {
                await handleConnectionError(error);
            }
        }

        // New error handling function
        async function handleConnectionError(error) {
            console.error('Connection error:', error);
            document.getElementById('statusBar').textContent = 'Connection Error: ' + error.message;
            document.getElementById('statusBar').classList.add('error');
            
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                document.getElementById('statusBar').textContent = Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...;
                setTimeout(connectPort, RECONNECT_DELAY);
            } else {
                await disconnect();
            }
        }

        // Improved disconnect function
        async function disconnect() {
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            
            if (keepAliveInterval) {
                clearInterval(keepAliveInterval);
                keepAliveInterval = null;
            }

            try {
                if (reader) {
                    await reader.cancel();
                    await reader.releaseLock();
                    reader = null;
                }
                
                if (writer) {
                    await writer.close();
                    await writer.releaseLock();
                    writer = null;
                }
                
                if (port) {
                    await port.close();
                    port = null;
                }
            } catch (error) {
                console.error('Disconnect error:', error);
            }

            updateConnectionStatus(false);
            dataBuffer = '';  // Clear any partial data
            reconnectAttempts = 0;
        }

        // New function to update connection status
        function updateConnectionStatus(connected) {
            isConnected = connected;
            document.getElementById('connectBtn').textContent = connected ? 'Disconnect' : 'Connect';
            document.getElementById('connectBtn').classList.toggle('connected', connected);
            document.getElementById('saveBtn').disabled = !connected;
            document.getElementById('loadBtn').disabled = !connected;
            document.getElementById('statusBar').textContent = connected ? 'Connected' : 'Disconnected';
            document.getElementById('statusBar').classList.toggle('connected', connected);
            document.getElementById('statusBar').classList.remove('error');
            
            if (!connected) {
                clearValues();
            }
        }

        // New connection check function
        async function checkConnection() {
            if (isConnected) {
                try {
                    await sendCommand('TABLE');
                    connectionTimeout = setTimeout(checkConnection, 5000);
                } catch (error) {
                    await handleConnectionError(error);
                }
            }
        }

        // Remove duplicate functions and replace with these improved versions
        async function startReading() {
            while (port && port.readable) {
                try {
                    const reader = port.readable.getReader();
                    try {
                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) break;
                            
                            const text = new TextDecoder().decode(value);
                            dataBuffer += text;
                            
                            const lines = dataBuffer.split('\n');
                            dataBuffer = lines.pop() || '';
                            
                            for (const line of lines) {
                                if (line.trim()) {
                                    console.log('Received:', line.trim()); // Debug line
                                    processLine(line.trim());
                                }
                            }
                        }
                    } finally {
                        reader.releaseLock();
                    }
                } catch (error) {
                    console.error('Read error:', error);
                    await handleConnectionError(error);
                    break;
                }
            }
        }

        function processLine(line) {
            console.log('Processing line:', line); // Debug line
            try {
                if (line.startsWith('DATA,')) {
                    const [_, freq, rpm, oil, pwml] = line.split(',');
                    const values = {
                        freq: parseFloat(freq),
                        rpm: parseFloat(rpm),
                        oil: parseFloat(oil),
                        pwml: parseFloat(pwml)
                    };
                    
                    if (!Object.values(values).some(isNaN)) {
                        document.getElementById('frequency').value = values.freq.toFixed(2);
                        document.getElementById('rpm').value = values.rpm.toFixed(0);
                        document.getElementById('oil').value = values.oil.toFixed(1);
                        document.getElementById('pwml').value = values.pwml.toFixed(2);
                        document.getElementById('current-rpm').textContent = ${values.rpm.toFixed(0)} RPM | ${values.oil.toFixed(1)}%;
                        lastValidData = values;
                        updateCurrentValues(values.rpm, values.oil);
                    }
                }
                else if (line.startsWith('TABLE,')) {
                    const [_, index, rpm, oil] = line.split(',');
                    const idx = parseInt(index);
                    const rpmValue = parseFloat(rpm);
                    const oilValue = parseFloat(oil);
                    
                    if (!isNaN(idx) && !isNaN(rpmValue) && !isNaN(oilValue)) {
                        const rows = document.querySelectorAll('#calibrationTable tbody tr');
                        if (rows[idx]) {
                            const currentCell = rows[idx].querySelector('.current-value');
                            if (currentCell) {
                                currentCell.textContent = Existing: RPM ${rpmValue.toFixed(1)} | Oil: ${oilValue.toFixed(1)}%;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Process line error:', error, 'Line:', line);
            }
        }

        // Connect to Arduino
        async function connect() {
            if (port) {
                await disconnect();
                return;
            }
            
            try {
                port = await navigator.serial.requestPort();
                await port.open({ 
                    baudRate: 115200,
                    dataBits: 8,
                    stopBits: 1,
                    parity: "none",
                    bufferSize: 4096,  // Increased buffer size
                    flowControl: "none"
                });

                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                document.getElementById('connectBtn').textContent = 'Disconnect';
                document.getElementById('connectBtn').classList.add('connected');
                document.getElementById('saveBtn').disabled = false;